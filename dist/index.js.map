{
  "version": 3,
  "sources": ["../shape.ts"],
  "sourcesContent": ["function deepEquals(a: any, b: any) {\r\n  return JSON.stringify(a) === JSON.stringify(b);\r\n}\r\n\r\nfunction deepClone(a: any) {\r\n  return JSON.parse(JSON.stringify(a));\r\n}\r\n\r\nexport interface ScalarShape {\r\n  kind: 'scalar';\r\n  name: 'null' | 'string' | 'number' | 'boolean' | 'bigint';\r\n}\r\n\r\nconst NULL_SHAPE: ScalarShape = { kind: 'scalar', name: 'null' };\r\n\r\nexport interface ObjectShape {\r\n  kind: 'object';\r\n  children: Record<string, Shape>;\r\n}\r\n\r\nexport interface ArrayShape {\r\n  kind: 'array';\r\n  children: Shape;\r\n}\r\n\r\nexport interface VariedShape {\r\n  kind: 'varied';\r\n  children: Shape[];\r\n}\r\n\r\nexport type Shape =\r\n  | ArrayShape\r\n  | ObjectShape\r\n  | VariedShape\r\n  | ScalarShape\r\n  | {\r\n      kind: 'unknown';\r\n    };\r\n\r\nexport function levelPrefix(level: number) {\r\n  return [...Array(level * 2).keys()].map((c) => ' ').join('');\r\n}\r\n\r\nexport function toString(shape: Shape, level = 0): string {\r\n  switch (shape.kind) {\r\n    case 'scalar':\r\n      return levelPrefix(level) + shape.name;\r\n    case 'array':\r\n      return (\r\n        levelPrefix(level) + 'Array of\\n' + toString(shape.children, level + 1)\r\n      );\r\n    case 'object': {\r\n      const keys = Object.keys(shape.children);\r\n      return (\r\n        levelPrefix(level) +\r\n        ('Object ' +\r\n          (keys.length\r\n            ? 'with\\n' +\r\n              keys\r\n                .map(\r\n                  (k) =>\r\n                    `${levelPrefix(level + 1)}'${k}' of\\n${toString(\r\n                      shape.children[k],\r\n                      level + 2\r\n                    )}`\r\n                )\r\n                .join(',\\n')\r\n            : '(empty)'))\r\n      );\r\n    }\r\n    case 'varied':\r\n      return shape.children.map((c) => toString(c, level)).join(' or\\n');\r\n    case 'unknown':\r\n      return levelPrefix(level) + 'Unknown';\r\n  }\r\n}\r\n\r\nfunction walkVaried(varied: VariedShape, cb: (a0: Shape) => boolean | void) {\r\n  const stack: Array<Shape> = [varied];\r\n  while (stack.length) {\r\n    const top = stack.pop();\r\n    if (top.kind === 'varied') {\r\n      top.children.map((c) => stack.push(c));\r\n    }\r\n\r\n    if (cb(top)) {\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nfunction addUniqueVaried(maybeVaried: Shape, shape: Shape) {\r\n  if (\r\n    !maybeVaried ||\r\n    (maybeVaried.kind === 'varied' &&\r\n      (!maybeVaried.children || !maybeVaried.children.length))\r\n  ) {\r\n    return shape;\r\n  }\r\n\r\n  if (maybeVaried.kind === 'varied') {\r\n    const varied: VariedShape = maybeVaried;\r\n\r\n    let found = false;\r\n    walkVaried(varied, (child: Shape) => {\r\n      // Don't try to use variedMerge here, it doesn't recurse correctly.\r\n      if (shape.kind === 'varied') {\r\n        walkVaried(shape, (toAddChild: Shape) => {\r\n          if (deepEquals(child, toAddChild)) {\r\n            found = true;\r\n            return true;\r\n          }\r\n        });\r\n\r\n        if (found) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      //console.log('attempting to add ', shape, 'comparing to ', child, 'is equal?', deepEquals(child, shape));\r\n      if (deepEquals(child, shape)) {\r\n        found = true;\r\n        return true;\r\n      }\r\n    });\r\n\r\n    // Don't add the same shape twice\r\n    if (found) {\r\n      return varied;\r\n    }\r\n  }\r\n\r\n  const result: VariedShape = {\r\n    kind: 'varied',\r\n    children: [maybeVaried, shape],\r\n  };\r\n  return result;\r\n}\r\n\r\nfunction variedMerge(a: VariedShape, b: VariedShape): VariedShape {\r\n  let varied: VariedShape = { kind: 'varied', children: [] };\r\n  for (const side of [a, b]) {\r\n    walkVaried(side, (child) => {\r\n      varied = addUniqueVaried(varied, child) as VariedShape;\r\n    });\r\n  }\r\n\r\n  return varied;\r\n}\r\n\r\nfunction objectMerge(a: ObjectShape, b: ObjectShape): ObjectShape {\r\n  const aKeys = Object.keys(a.children);\r\n  const bKeys = Object.keys(b.children);\r\n  const merged: ObjectShape = {\r\n    kind: 'object',\r\n    children: {},\r\n  };\r\n\r\n  // First check all aKeys to see if they differ in b\r\n  for (let i = 0; i < aKeys.length; i++) {\r\n    const key = aKeys[i];\r\n    if (bKeys.includes(key)) {\r\n      merged.children[key] = merge([a.children[key], b.children[key]]).children;\r\n      continue;\r\n    }\r\n\r\n    // If they are new, they must sometimes be null/undefined\r\n    merged.children[key] = addUniqueVaried(a.children[key], NULL_SHAPE);\r\n  }\r\n\r\n  // now check all bKeys to see if they are new to a\r\n  for (let i = 0; i < bKeys.length; i++) {\r\n    const key = bKeys[i];\r\n    if (!aKeys.includes(key)) {\r\n      // If they are new, they must sometimes be null/undefined\r\n      merged.children[key] = addUniqueVaried(b.children[key], NULL_SHAPE);\r\n      continue;\r\n    }\r\n\r\n    // Do nothing, it's already been merged.\r\n  }\r\n\r\n  return merged;\r\n}\r\n\r\nfunction getNRandomUniqueElements(arraySize: number, maxSampleSize: number) {\r\n  if (!maxSampleSize || arraySize <= maxSampleSize) {\r\n    return [...Array(arraySize).keys()].map((_, i) => i);\r\n  }\r\n\r\n  const unique = [];\r\n  while (unique.length < maxSampleSize) {\r\n    const random = Math.floor(Math.random() * (arraySize - 1)) + 1;\r\n    if (unique.indexOf(random) === -1) {\r\n      unique.push(random);\r\n    }\r\n  }\r\n\r\n  return unique;\r\n}\r\n\r\nexport function merge(\r\n  shapes: Array<Shape>,\r\n  sampleSizeMax?: number\r\n): ArrayShape {\r\n  const merged: ArrayShape = { kind: 'array', children: { kind: 'unknown' } };\r\n  if (!shapes.length) {\r\n    return merged;\r\n  }\r\n\r\n  const randomUniqueIndexes = getNRandomUniqueElements(\r\n    shapes.length,\r\n    sampleSizeMax || shapes.length\r\n  );\r\n\r\n  merged.children = shapes[0];\r\n  for (let i = 0; i < randomUniqueIndexes.length; i++) {\r\n    const shape = shapes[randomUniqueIndexes[i]];\r\n    if (deepEquals(merged.children, shape)) {\r\n      continue;\r\n    }\r\n\r\n    if (shape.kind === 'object' && merged.children.kind === 'object') {\r\n      merged.children = objectMerge(deepClone(merged.children), shape);\r\n      continue;\r\n    }\r\n\r\n    if (shape.kind === 'array' && merged.children.kind === 'array') {\r\n      merged.children = merge([\r\n        deepClone(merged.children).children,\r\n        shape.children,\r\n      ]);\r\n      continue;\r\n    }\r\n\r\n    // It's possible this case isn't even possible since 'varied' is\r\n    // something that only gets applied during post-processing here.\r\n    if (shape.kind === 'varied' && merged.children.kind === 'varied') {\r\n      merged.children = variedMerge(\r\n        shape as VariedShape,\r\n        deepClone(merged.children) as VariedShape\r\n      );\r\n      continue;\r\n    }\r\n\r\n    if (shape.kind === merged.children.kind && shape.kind !== 'scalar') {\r\n      throw new Error(\r\n        `Missing type equality condition for ${shape.kind} merge.`\r\n      );\r\n    }\r\n\r\n    merged.children = addUniqueVaried(merged.children, shape);\r\n  }\r\n\r\n  return merged;\r\n}\r\n\r\nfunction shapeOfArray(data: any[], sampleSizeMax: number) {\r\n  const shapes = data.map((d) => shape(d, sampleSizeMax));\r\n  return merge(shapes, sampleSizeMax);\r\n}\r\n\r\nfunction shapeOfObject(\r\n  data: Record<string, any>,\r\n  sampleSizeMax: number\r\n): Shape {\r\n  const keys = Object.keys(data);\r\n\r\n  const randomUniqueIndexes = getNRandomUniqueElements(\r\n    keys.length,\r\n    sampleSizeMax\r\n  );\r\n\r\n  const os: ObjectShape = { kind: 'object', children: {} };\r\n  for (let i = 0; i < randomUniqueIndexes.length; i++) {\r\n    const key = keys[randomUniqueIndexes[i]];\r\n    os.children[key] = shape(data[key], sampleSizeMax);\r\n  }\r\n\r\n  return os;\r\n}\r\n\r\nexport function shape(data: any, sampleSizeMax = 5000): Shape {\r\n  try {\r\n    if (Array.isArray(data)) {\r\n      return shapeOfArray(data as any[], sampleSizeMax);\r\n    }\r\n\r\n    if (data === null) {\r\n      return { kind: 'scalar', name: 'null' };\r\n    }\r\n\r\n    if (typeof data === 'object') {\r\n      return shapeOfObject(data, sampleSizeMax);\r\n    }\r\n\r\n    if (typeof data === 'number') {\r\n      return { kind: 'scalar', name: 'number' };\r\n    }\r\n\r\n    if (typeof data === 'bigint') {\r\n      return { kind: 'scalar', name: 'bigint' };\r\n    }\r\n\r\n    if (typeof data === 'undefined') {\r\n      return { kind: 'scalar', name: 'null' };\r\n    }\r\n\r\n    if (typeof data === 'boolean') {\r\n      return { kind: 'scalar', name: 'boolean' };\r\n    }\r\n\r\n    return { kind: 'scalar', name: 'string' };\r\n  } catch (e) {\r\n    console.error(e);\r\n    return { kind: 'unknown' };\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
