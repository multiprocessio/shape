{
  "version": 3,
  "sources": ["../shape.ts"],
  "sourcesContent": ["function deepEquals(a: any, b: any) {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n\nfunction deepClone(a: any) {\n  return JSON.parse(JSON.stringify(a));\n}\n\nexport interface ScalarShape {\n  kind: 'scalar';\n  name: 'null' | 'string' | 'number' | 'boolean' | 'bigint';\n}\n\nconst NULL_SHAPE: ScalarShape = { kind: 'scalar', name: 'null' };\n\nexport interface ObjectShape {\n  kind: 'object';\n  children: Record<string, Shape>;\n}\n\nexport interface ArrayShape {\n  kind: 'array';\n  children: Shape;\n}\n\nexport interface VariedShape {\n  kind: 'varied';\n  children: Shape[];\n}\n\nexport type Shape =\n  | ArrayShape\n  | ObjectShape\n  | VariedShape\n  | ScalarShape\n  | {\n      kind: 'unknown';\n    };\n\nexport function levelPrefix(level: number) {\n  return [...Array(level * 2).keys()].map((c) => ' ').join('');\n}\n\nexport function toString(shape: Shape, level = 0): string {\n  switch (shape.kind) {\n    case 'scalar':\n      return levelPrefix(level) + shape.name;\n    case 'array':\n      return (\n        levelPrefix(level) + 'Array of\\n' + toString(shape.children, level + 1)\n      );\n    case 'object':\n      return (\n        levelPrefix(level) +\n        ('Object with\\n' +\n          Object.keys(shape.children)\n            .map(\n              (k) =>\n                `${levelPrefix(level + 1)}'${k}' of\\n${toString(\n                  shape.children[k],\n                  level + 2\n                )}`\n            )\n            .join(',\\n'))\n      );\n    case 'varied':\n      return shape.children.map((c) => toString(c, level)).join(' or\\n');\n    case 'unknown':\n      return levelPrefix(level) + 'Unknown';\n  }\n}\n\nfunction walkVaried(varied: VariedShape, cb: (a0: Shape) => boolean | void) {\n  const stack: Array<Shape> = [varied];\n  while (stack) {\n    const top = stack.pop();\n    if (top.kind === 'varied') {\n      top.children.map((c) => stack.push(c));\n    }\n\n    if (cb(top)) {\n      break;\n    }\n  }\n}\n\nfunction addUniqueVaried(maybeVaried: Shape, shape: Shape) {\n  if (!maybeVaried) {\n    return shape;\n  }\n\n  if (maybeVaried.kind === 'varied') {\n    const varied: VariedShape = maybeVaried;\n\n    let found = false;\n    walkVaried(varied, (child: Shape) => {\n      if (deepEquals(child, shape)) {\n        found = true;\n        return true;\n      }\n    });\n\n    // Don't add the same shape twice\n    if (found) {\n      return varied;\n    }\n  }\n\n  const result: VariedShape = {\n    kind: 'varied',\n    children: [deepClone(maybeVaried), shape],\n  };\n  return result;\n}\n\nfunction variedMerge(a: VariedShape, b: VariedShape): VariedShape {\n  let varied: VariedShape = { kind: 'varied', children: [] };\n  for (const side of [a, b]) {\n    walkVaried(side, (child) => {\n      varied = addUniqueVaried(varied, child) as VariedShape;\n    });\n  }\n\n  return varied;\n}\n\nfunction objectMerge(a: ObjectShape, b: ObjectShape): ObjectShape {\n  const aKeys = Object.keys(a.children);\n  const bKeys = Object.keys(b.children);\n  const merged: ObjectShape = {\n    kind: 'object',\n    children: {},\n  };\n\n  // First check all aKeys to see if they differ in b\n  for (let i = 0; i < aKeys.length; i++) {\n    const key = aKeys[i];\n    if (bKeys.includes(key)) {\n      merged.children[key] = merge([a.children[key], b.children[key]]).children;\n      continue;\n    }\n\n    // If they are new, they must sometimes be null/undefined\n    merged.children[key] = addUniqueVaried(a.children[key], NULL_SHAPE);\n  }\n\n  // now check all bKeys to see if they are new to a\n  for (let i = 0; i < bKeys.length; i++) {\n    const key = bKeys[i];\n    if (!aKeys.includes(key)) {\n      // If they are new, they must sometimes be null/undefined\n      merged.children[key] = addUniqueVaried(b.children[key], NULL_SHAPE);\n      continue;\n    }\n\n    // Do nothing, it's already been merged.\n  }\n\n  return merged;\n}\n\nfunction getNRandomUniqueElements(arraySize: number, maxSampleSize: number) {\n  if (!maxSampleSize || arraySize <= maxSampleSize) {\n    return [...Array(arraySize).keys()].map((_, i) => i);\n  }\n\n  const unique = [];\n  while (unique.length < maxSampleSize) {\n    const random = Math.floor(Math.random() * (arraySize - 1)) + 1;\n    if (unique.indexOf(random) === -1) {\n      unique.push(random);\n    }\n  }\n\n  return unique;\n}\n\nfunction merge(shapes: Array<Shape>, sampleSizeMax?: number): ArrayShape {\n  const merged: ArrayShape = { kind: 'array', children: { kind: 'unknown' } };\n  if (!shapes.length) {\n    return merged;\n  }\n\n  const randomUniqueIndexes = getNRandomUniqueElements(\n    shapes.length,\n    sampleSizeMax || shapes.length\n  );\n\n  merged.children = shapes[0];\n  for (let i = 0; i < randomUniqueIndexes.length; i++) {\n    const shape = shapes[randomUniqueIndexes[i]];\n    if (deepEquals(merged.children, shape)) {\n      continue;\n    }\n\n    if (shape.kind === 'object' && merged.children.kind === 'object') {\n      merged.children = objectMerge(deepClone(merged.children), shape);\n      continue;\n    }\n\n    if (shape.kind === 'array' && merged.children.kind === 'array') {\n      merged.children = merge([\n        deepClone(merged.children).children,\n        shape.children,\n      ]);\n      continue;\n    }\n\n    if (shape.kind === 'varied' && merged.children.kind === 'varied') {\n      merged.children = variedMerge(\n        shape as VariedShape,\n        deepClone(merged.children) as VariedShape\n      );\n      continue;\n    }\n\n    if (shape.kind === merged.children.kind && shape.kind !== 'scalar') {\n      throw new Error(\n        `Missing type equality condition for ${shape.kind} merge.`\n      );\n    }\n\n    merged.children = addUniqueVaried(merged.children, shape);\n  }\n\n  return merged;\n}\n\nfunction shapeOfArray(data: any[], sampleSizeMax: number) {\n  const shapes = data.map((d) => shape(d, sampleSizeMax));\n  return merge(shapes, sampleSizeMax);\n}\n\nfunction shapeOfObject(\n  data: Record<string, any>,\n  sampleSizeMax: number\n): Shape {\n  const keys = Object.keys(data);\n\n  const randomUniqueIndexes = getNRandomUniqueElements(\n    keys.length,\n    sampleSizeMax\n  );\n\n  const os: ObjectShape = { kind: 'object', children: {} };\n  for (let i = 0; i < randomUniqueIndexes.length; i++) {\n    const key = keys[randomUniqueIndexes[i]];\n    os.children[key] = shape(data[key], sampleSizeMax);\n  }\n\n  return os;\n}\n\nexport function shape(data: any, sampleSizeMax = 5000): Shape {\n  try {\n    if (Array.isArray(data)) {\n      return shapeOfArray(data as any[], sampleSizeMax);\n    }\n\n    if (data === null) {\n      return { kind: 'scalar', name: 'null' };\n    }\n\n    if (typeof data === 'object') {\n      return shapeOfObject(data, sampleSizeMax);\n    }\n\n    if (typeof data === 'number') {\n      return { kind: 'scalar', name: 'number' };\n    }\n\n    if (typeof data === 'bigint') {\n      return { kind: 'scalar', name: 'bigint' };\n    }\n\n    if (typeof data === 'undefined') {\n      return { kind: 'scalar', name: 'null' };\n    }\n\n    if (typeof data === 'boolean') {\n      return { kind: 'scalar', name: 'boolean' };\n    }\n\n    return { kind: 'scalar', name: 'string' };\n  } catch (e) {\n    console.error(e);\n    return { kind: 'unknown' };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
