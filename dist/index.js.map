{
  "version": 3,
  "sources": ["../shape.ts"],
  "sourcesContent": ["function deepEquals(a: any, b: any) {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n\nfunction deepClone(a: any) {\n  return JSON.parse(JSON.stringify(a));\n}\n\nexport type ScalarShape = {\n  kind: 'scalar';\n  name: 'null' | 'string' | 'number' | 'boolean' | 'bigint';\n};\n\nexport type ObjectShape = {\n  kind: 'object';\n  children: Record<string, Shape>;\n};\n\nexport type ArrayShape = {\n  kind: 'array';\n  children: Shape;\n};\n\nexport type VariedShape = {\n  kind: 'varied';\n  children: Shape[];\n};\n\nexport type Shape =\n  | ArrayShape\n  | ObjectShape\n  | VariedShape\n  | ScalarShape\n  | {\n      kind: 'unknown';\n    };\n\nexport function levelPrefix(level: number) {\n  return [...Array(level * 2).keys()].map((c) => ' ').join('');\n}\n\nexport function toString(shape: Shape, level = 0): string {\n  switch (shape.kind) {\n    case 'scalar':\n      return levelPrefix(level) + shape.name;\n    case 'array':\n      return (\n        levelPrefix(level) + 'Array of\\n' + toString(shape.children, level + 1)\n      );\n    case 'object':\n      return (\n        levelPrefix(level) +\n        ('Object with\\n' +\n          Object.keys(shape.children)\n            .map(\n              (k) =>\n                `${levelPrefix(level + 1)}'${k}' of\\n${toString(\n                  shape.children[k],\n                  level + 2\n                )}`\n            )\n            .join(',\\n'))\n      );\n    case 'varied':\n      return shape.children.map((c) => toString(c, level)).join(' or\\n');\n    case 'unknown':\n      return levelPrefix(level) + 'Unknown';\n  }\n}\n\nfunction variedMerge(a: VariedShape, b: VariedShape): VariedShape {\n  const varied = { kind: 'varied', children: a.children.slice() };\n  for (const bChild of b.children) {\n    for (const aChild of a.children) {\n      if (deepEquals(bChild, aChild)) {\n        continue;\n      }\n\n      varied.children.push(bChild);\n    }\n  }\n\n  return varied;\n}\n\nfunction objectMerge(a: ObjectShape, b: ObjectShape): ObjectShape {\n  const aKeys = Object.keys(a.children);\n  const bKeys = Object.keys(b.children);\n  const merged: ObjectShape = {\n    kind: 'object',\n    children: {},\n  };\n\n  // First check all aKeys to see if they differ in b\n  for (let i = 0; i < aKeys.length; i++) {\n    const key = aKeys[i];\n    if (bKeys.includes(key)) {\n      merged.children[key] = merge([a.children[key], b.children[key]]).children;\n      continue;\n    }\n\n    // If they are new, they must sometimes be null/undefined\n    merged.children[key] = {\n      kind: 'varied',\n      children: [a.children[key], { kind: 'scalar', name: 'null' }],\n    };\n  }\n\n  // now check all bKeys to see if they are new to a\n  for (let i = 0; i < bKeys.length; i++) {\n    const key = bKeys[i];\n    if (!aKeys.includes(key)) {\n      // If they are new, they must sometimes be null/undefined\n      merged.children[key] = {\n        kind: 'varied',\n        children: [b.children[key], { kind: 'scalar', name: 'null' }],\n      };\n    }\n\n    // Do nothing, it's already been merged.\n  }\n\n  return merged;\n}\n\nfunction getNRandomUniqueElements(arraySize: number, maxSampleSize: number) {\n  if (!maxSampleSize || arraySize <= maxSampleSize) {\n    return [...Array(arraySize).keys()].map((_, i) => i);\n  }\n\n  const unique = [];\n  while (unique.length < maxSampleSize) {\n    const random = Math.floor(Math.random() * (arraySize - 1)) + 1;\n    if (unique.indexOf(random) === -1) {\n      unique.push(random);\n    }\n  }\n\n  return unique;\n}\n\nfunction merge(shapes: Array<Shape>, sampleSizeMax: number): Shape {\n  const merged: Shape = { kind: 'array', children: { kind: 'unknown' } };\n  if (!shapes.length) {\n    return merged;\n  }\n\n  const randomUniqueIndexes = getNRandomUniqueElements(\n    shapes.length,\n    sampleSizeMax\n  );\n\n  merged.children = shapes[0];\n  for (let i = 0; i < randomUniqueIndexes.length; i++) {\n    const shape = shapes[randomUniqueIndexes[i]];\n    if (deepEquals(merged.children, shape)) {\n      continue;\n    }\n\n    if (shape.kind === 'object' && merged.children.kind === 'object') {\n      merged.children = objectMerge(deepClone(merged.children), shape);\n      continue;\n    }\n\n    if (shape.kind === 'array' && merged.children.kind === 'array') {\n      merged.children = merge(\n        [deepClone(merged.children).children, shape.children],\n        sampleSizeMax\n      );\n      continue;\n    }\n\n    if (shape.kind === 'varied' && merged.children.kind === 'varied') {\n      merged.children = variedMerge(\n        shape as VariedShape,\n        deepClone(merged.children) as VariedShape\n      );\n      continue;\n    }\n\n    if (shape.kind === merged.children.kind && shape.kind !== 'scalar') {\n      throw new Error(\n        `Missing type equality condition for ${shape.kind} merge.`\n      );\n    }\n\n    // Don't add varied items twice\n    if (merged.children.kind === 'varied') {\n      let stack = [merged.children];\n      let found = false;\n      while (stack) {\n        const top = stack.pop();\n        if (top.kind === 'varied') {\n          top.children.map((c) => stack.push(c));\n        }\n\n        if (deepEquals(top, shape)) {\n          found = true;\n          break;\n        }\n      }\n\n      // Don't add twice\n      if (found) {\n        continue;\n      }\n\n      // Allow the new shape to be added as a varied child below\n    }\n\n    // Can only merge shapes of the same type\n    merged.children = {\n      kind: 'varied',\n      children: [deepClone(merged.children), shape],\n    };\n  }\n\n  return merged;\n}\n\nfunction shapeOfArray(data: any[], sampleSizeMax: number) {\n  const shapes = data.map((d) => shape(d, sampleSizeMax));\n  return merge(shapes, sampleSizeMax);\n}\n\nfunction shapeOfObject(\n  data: Record<string, any>,\n  sampleSizeMax: number\n): Shape {\n  const keys = Object.keys(data);\n\n  const randomUniqueIndexes = getNRandomUniqueElements(\n    keys.length,\n    sampleSizeMax\n  );\n\n  const os: ObjectShape = { kind: 'object', children: {} };\n  for (let i = 0; i < randomUniqueIndexes.length; i++) {\n    const key = keys[randomUniqueIndexes[i]];\n    os.children[key] = shape(data[key], sampleSizeMax);\n  }\n\n  return os;\n}\n\nexport function shape(data: any, sampleSizeMax = 5000): Shape {\n  try {\n    if (Array.isArray(data)) {\n      return shapeOfArray(data as any[], sampleSizeMax);\n    }\n\n    if (data === null) {\n      return { kind: 'scalar', name: 'null' };\n    }\n\n    if (typeof data === 'object') {\n      return shapeOfObject(data, sampleSizeMax);\n    }\n\n    if (typeof data === 'number') {\n      return { kind: 'scalar', name: 'number' };\n    }\n\n    if (typeof data === 'bigint') {\n      return { kind: 'scalar', name: 'bigint' };\n    }\n\n    if (typeof data === 'undefined') {\n      return { kind: 'scalar', name: 'null' };\n    }\n\n    if (typeof data === 'boolean') {\n      return { kind: 'scalar', name: 'boolean' };\n    }\n\n    return { kind: 'scalar', name: 'string' };\n  } catch (e) {\n    console.error(e);\n    return { kind: 'unknown' };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
